# @RestController -

In Spring Boot, the `@RestController` annotation is a specialized version of `@Controller` that simplifies the creation of RESTful web services. It combines `@Controller` and `@ResponseBody`, which means that instead of returning a view (like in a traditional MVC controller), the controller methods return data directly, usually in the form of JSON or XML.

Here’s an in-depth look at how `@RestController` works, its features, and its use in Spring Boot:

### 1. **Definition and Purpose**

The `@RestController` annotation is used in Spring MVC applications to define RESTful web services. It tells Spring that the class is a web controller and that the return values of its methods should be written directly to the HTTP response body, rather than resolving to a view (like a JSP page).

It’s equivalent to combining the `@Controller` and `@ResponseBody` annotations.

#### Example:

```java
@RestController
public class MyRestController {

    @GetMapping("/hello")
    public String hello() {
        return "Hello, World!";
    }
}
```

Here, the `hello()` method returns the string `"Hello, World!"`, which will be sent as the HTTP response body, typically in plain text or JSON format depending on the request headers.

### 2. **Key Features of `@RestController`**

- **Auto-conversion to JSON or XML**: By default, Spring Boot uses **Jackson** (for JSON) or **JAXB** (for XML) to automatically convert Java objects returned by a method into JSON or XML. This makes it easy to create RESTful APIs.
    Example:
  
  ```java
  @RestController
  public class UserController {
  
      @GetMapping("/user")
      public User getUser() {
          return new User("John", "Doe");
      }
  }
  ```
  
    When a request is made to `/user`, the `User` object is automatically serialized to JSON, producing a response like:
  
  ```json
  {
      "firstName": "John",
      "lastName": "Doe"
  }
  ```

- **No View Resolution**: Unlike a regular `@Controller`, `@RestController` methods don’t resolve to a view or template (like JSP, Thymeleaf). Instead, the method's return value is directly written to the HTTP response as JSON, XML, or plain text.

- **Simplified REST API Creation**: `@RestController` significantly reduces the boilerplate needed to create RESTful web services by automatically including the `@ResponseBody` functionality, eliminating the need to add it to every method manually.

### 3. **Spring MVC Annotations with `@RestController`**

- **`@GetMapping`**, **`@PostMapping`**, **`@PutMapping`**, **`@DeleteMapping`**:
  These annotations are shorthand for mapping HTTP requests to specific handler methods based on the HTTP method type (GET, POST, PUT, DELETE).
  Example:
  
  ```java
  @RestController
  @RequestMapping("/api")
  public class UserController {
  
      @GetMapping("/users/{id}")
      public User getUserById(@PathVariable Long id) {
          return userService.findById(id);
      }
  
      @PostMapping("/users")
      public User createUser(@RequestBody User user) {
          return userService.save(user);
      }
  }
  ```
  
  - `@GetMapping`: Maps HTTP GET requests.
  - `@PostMapping`: Maps HTTP POST requests.
  - `@PutMapping`: Maps HTTP PUT requests.
  - `@DeleteMapping`: Maps HTTP DELETE requests.

- **`@RequestBody`**: Binds the HTTP request body to a method parameter. It’s used to handle POST, PUT, or PATCH requests where data is sent in the body (typically in JSON or XML).
  Example:
  
  ```java
  @PostMapping("/users")
  public User createUser(@RequestBody User user) {
      return userService.save(user);
  }
  ```
  
  The `@RequestBody` annotation binds the incoming request body (in JSON format) to the `user` parameter of the method. Spring uses Jackson to convert the incoming JSON into a Java object.

- **`@PathVariable`**: Used to extract values from the URL path and map them to method parameters.
  Example:
  
  ```java
  @GetMapping("/users/{id}")
  public User getUserById(@PathVariable Long id) {
      return userService.findById(id);
  }
  ```
  
  Here, `{id}` in the URL is mapped to the `id` parameter of the `getUserById` method.

- **`@RequestParam`**: Binds query parameters from the request URL to method parameters.
  Example:
  
  ```java
  @GetMapping("/users")
  public List<User> getUsersByRole(@RequestParam String role) {
      return userService.findByRole(role);
  }
  ```
  
  If you request `/users?role=admin`, the value of the `role` query parameter will be passed to the `role` method parameter.

- **`@ResponseStatus`**: You can set the HTTP status code returned by a method. For example, you can return a 201 (Created) status after creating a resource.
  Example:
  
  ```java
  @PostMapping("/users")
  @ResponseStatus(HttpStatus.CREATED)
  public User createUser(@RequestBody User user) {
      return userService.save(user);
  }
  ```
  
  Here, when a new user is created, the response will include an HTTP status of `201 Created`.

### 4. **Difference Between `@Controller` and `@RestController`**

| Feature                       | `@Controller`                                   | `@RestController`                            |
| ----------------------------- | ----------------------------------------------- | -------------------------------------------- |
| View Resolution               | Returns a view (e.g., HTML, JSP)                | Returns data (e.g., JSON, XML, text)         |
| Use with Front-end Frameworks | Common in MVC architecture (Thymeleaf, JSP)     | Common in RESTful APIs, typically JSON-based |
| Response Body                 | Requires `@ResponseBody` for JSON/XML responses | Implicitly includes `@ResponseBody`          |
| Typical Use Case              | Server-side rendered web applications           | REST APIs and microservices                  |

### 5. **Error Handling in `@RestController`**

Spring Boot allows the use of global exception handling using `@ControllerAdvice` for `@RestController`. This lets you manage errors in a standardized way across your application.

Example:

```java
@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(UserNotFoundException.class)
    @ResponseStatus(HttpStatus.NOT_FOUND)
    public ErrorResponse handleUserNotFound(UserNotFoundException ex) {
        return new ErrorResponse("User not found", ex.getMessage());
    }
}
```

Here, if a `UserNotFoundException` is thrown in any `@RestController`, the global exception handler will catch it and return a JSON response with an appropriate error message.

### 6. **Returning HTTP Status Codes**

You can control the HTTP status codes returned by `@RestController` methods either by using the `ResponseEntity` class or the `@ResponseStatus` annotation.

- **`ResponseEntity`**: Allows you to customize both the response body and the status code.
  Example:
  
  ```java
  @GetMapping("/users/{id}")
  public ResponseEntity<User> getUserById(@PathVariable Long id) {
      User user = userService.findById(id);
      if (user == null) {
          return new ResponseEntity<>(HttpStatus.NOT_FOUND);
      }
      return new ResponseEntity<>(user, HttpStatus.OK);
  }
  ```
  
  In this example, if the user is found, a `200 OK` response is returned. Otherwise, a `404 Not Found` is returned.

### 7. **Content Negotiation**

Spring Boot supports content negotiation, which allows your `@RestController` to return different formats (e.g., JSON, XML) based on the `Accept` header in the HTTP request. By default, JSON is returned, but you can configure XML or other formats.

For example, Spring uses **Jackson** for JSON and **JAXB** for XML. If a request includes the header `Accept: application/xml`, and if the appropriate libraries are on the classpath, Spring will convert the response to XML.

### 8. **Conclusion**

The `@RestController` annotation is a key feature in Spring Boot for creating RESTful APIs. It simplifies the development of APIs by automatically converting Java objects into JSON (or XML) and writing them to the HTTP response. It also eliminates the need for view resolution and reduces boilerplate code by combining `@Controller` and `@ResponseBody`. When paired with other Spring annotations like `@GetMapping`, `@PostMapping`, and `@RequestBody`, it provides an efficient and powerful way to build web services.
