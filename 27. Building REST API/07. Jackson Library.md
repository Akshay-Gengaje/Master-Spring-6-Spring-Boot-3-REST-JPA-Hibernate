# Jackson Library -

The **Jackson** library is a popular and powerful tool in Java for converting Java objects to JSON (serialization) and JSON to Java objects (deserialization). In the context of a **Spring Boot REST API**, Jackson is the default library used by **Spring MVC** to handle JSON conversions. It allows seamless transformation of Java objects to JSON format when returning responses and vice versa when receiving JSON in requests.

### Key Concepts of Jackson in Spring Boot

1. **Serialization**: The process of converting a Java object into a JSON representation (e.g., for HTTP responses).
2. **Deserialization**: The process of converting a JSON payload into a Java object (e.g., from an HTTP request body).

### How Jackson Works in Spring Boot

Spring Boot automatically configures Jackson as the default JSON processor, so developers don't need to explicitly set it up unless customization is needed. Jackson works behind the scenes to convert Java objects (POJOs) to JSON and vice versa, using annotations and configurations for fine-tuning.

For example, when a Spring Boot REST controller returns a Java object, Jackson converts the object into a JSON format before sending it to the client. Similarly, when the controller receives JSON data in a request, Jackson deserializes it into a Java object.

### Example: Basic Usage in a Spring Boot REST API

#### 1. **Java POJO**

Let’s say you have a `User` class that needs to be serialized to and deserialized from JSON.

```java
public class User {
    private Long id;
    private String name;
    private String email;

    // Getters and Setters
}
```

#### 2. **Spring Boot Controller**

In a typical Spring REST controller, you can handle requests and responses with JSON easily. Jackson will automatically convert the `User` object to JSON for responses and deserialize JSON into a `User` object for requests.

```java
@RestController
@RequestMapping("/api/users")
public class UserController {

    @PostMapping
    public ResponseEntity<User> createUser(@RequestBody User user) {
        // Jackson automatically deserializes the JSON request body into a User object
        // Business logic here (e.g., saving the user to the database)
        return new ResponseEntity<>(user, HttpStatus.CREATED);
    }

    @GetMapping("/{id}")
    public ResponseEntity<User> getUser(@PathVariable Long id) {
        // Assume userService.getUserById(id) returns a User object
        User user = userService.getUserById(id);
        // Jackson automatically serializes the User object into a JSON response
        return new ResponseEntity<>(user, HttpStatus.OK);
    }
}
```

In this example:

- The `@RequestBody` annotation tells Spring to convert the incoming JSON data into a `User` object (deserialization).
- When the `User` object is returned from the controller, Spring converts it into JSON using Jackson (serialization).

### Jackson Annotations for Customization

Jackson provides several annotations that help in customizing the serialization and deserialization processes. These annotations can be used to control how JSON is structured and how Java objects are mapped.

#### 1. **`@JsonProperty`**

- You can specify the name of the JSON field if it differs from the Java field name.

```java
public class User {
    @JsonProperty("user_id")
    private Long id;

    @JsonProperty("full_name")
    private String name;

    private String email;

    // Getters and Setters
}
```

In this case, Jackson will map the `id` field to `user_id` in JSON, and `name` to `full_name`.

#### 2. **`@JsonIgnore`**

- Excludes a field from serialization or deserialization.

```java
public class User {
    private Long id;

    @JsonIgnore
    private String password;

    private String email;

    // Getters and Setters
}
```

The `password` field will be ignored when converting the `User` object to JSON.

#### 3. **`@JsonInclude`**

- Controls the inclusion of fields based on certain criteria, like only including non-null fields in the output JSON.

```java
@JsonInclude(JsonInclude.Include.NON_NULL)
public class User {
    private Long id;
    private String name;
    private String email;

    // Getters and Setters
}
```

In this example, if any of the fields are `null`, they will not be included in the resulting JSON.

#### 4. **`@JsonFormat`**

- This annotation is useful for customizing date and time formats.

```java
public class User {
    private Long id;

    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd")
    private LocalDate dob;  // Date of birth

    private String email;

    // Getters and Setters
}
```

Here, the `dob` field will be serialized as a string in the format `yyyy-MM-dd` (e.g., `1990-01-01`).

#### 5. **`@JsonIgnoreProperties`**

- Used at the class level to ignore multiple properties during serialization or deserialization.

```java
@JsonIgnoreProperties({"password", "ssn"})
public class User {
    private Long id;
    private String name;
    private String password;
    private String ssn;  // Social Security Number
    private String email;

    // Getters and Setters
}
```

The `password` and `ssn` fields will be ignored globally for this class.

---

### Customizing Jackson in Spring Boot

You can configure Jackson globally by customizing how Spring Boot uses it. This is useful when you want specific formatting for dates, control over null values, or when dealing with custom serialization logic.

#### 1. **Global Configuration via `application.properties`**

You can set Jackson-specific properties in the `application.properties` or `application.yml` file to modify how Jackson handles serialization and deserialization.

For example, to include only non-null fields in your JSON globally:

```properties
spring.jackson.default-property-inclusion=non_null
```

To set a global date format for all date fields:

```properties
spring.jackson.date-format=yyyy-MM-dd
```

#### 2. **Custom ObjectMapper Configuration**

If you need more advanced customization, you can define a custom `ObjectMapper` bean. The `ObjectMapper` is the main class in Jackson that handles the serialization and deserialization.

```java
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class JacksonConfig {

    @Bean
    public ObjectMapper objectMapper() {
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.enable(SerializationFeature.INDENT_OUTPUT);  // Pretty print JSON
        return objectMapper;
    }
}
```

In this example, the custom `ObjectMapper` is configured to enable pretty-printing (indented output) of JSON responses.

#### 3. **Mix-ins**

Mix-ins allow you to customize the serialization/deserialization of third-party classes or classes where you don’t want to modify the source code directly.

```java
public abstract class UserMixin {
    @JsonIgnore
    private String password;
}
```

```java
@Configuration
public class JacksonConfig {
    @Bean
    public ObjectMapper objectMapper() {
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.addMixIn(User.class, UserMixin.class);
        return objectMapper;
    }
}
```

In this case, the `User` class will use the `UserMixin` annotations during serialization and deserialization, hiding the `password` field without modifying the original `User` class.

---

### Jackson Modules in Spring Boot

Jackson supports additional modules that extend its functionality for specific types or libraries.

#### 1. **Java 8 Date/Time Module**

If you're using Java 8's `LocalDate`, `LocalDateTime`, or other classes from the `java.time` package, you need to register the **Jackson JavaTimeModule**.

```java
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class JacksonConfig {

    @Bean
    public ObjectMapper objectMapper() {
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.registerModule(new JavaTimeModule());
        return objectMapper;
    }
}
```

#### 2. **Hibernate Module**

If you're working with JPA entities that have **lazy-loaded** relationships, you can use the Jackson Hibernate module to handle serialization of these entities correctly.

```java
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.hibernate5.Hibernate5Module;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class JacksonConfig {

    @Bean
    public ObjectMapper objectMapper() {
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.registerModule(new Hibernate5Module());
        return objectMapper;
    }
}
```

This module prevents issues like `LazyInitializationException` when serializing entities with lazy-loaded relationships.

---

### Conclusion

Jackson is a key library in **Spring Boot REST APIs** for handling JSON serialization and deserialization. Spring Boot auto-configures Jackson, but it also allows fine-tuned control through annotations, configuration properties, and custom `ObjectMapper` instances. Understanding how to work with Jackson helps ensure your API handles JSON data efficiently, flexibly, and in a way that meets the specific requirements of your application.
